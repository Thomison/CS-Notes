## 1.简述程序、进程和线程的区别

程序是在磁盘上静态的字节文件，它是持久的，而进程是加载到内存中并且动态执行的程序，它是临时的，一个程序可以对应多个进程。

进程与程序：
- 进程是一个正在执行的程序的实例
- 进程 = 进程控制块`PCB` + 程序 + 相关数据
- 引入进程的目的是 让多道程序能够并发的执行
- 程序是静态实体，而进程具有动态性，它是动态执行的、具有生命周期
- 进程与程序不存在一一对一的关系 => 一个程序的执行可以对应一个或多个进程

线程是在进程内部执行单元的划分，线程的出现提高了并发性，一个进程可以对应多个线程。进程是资源分配的最小单位，而线程是执行调度的最小单位。

## 2.论述进程控制块(PCB)的作用、存储内容 *

PCB位于内核地址空间，存放OS用来控制进程的数据。

存储内容主要分为三类：进程标识信息、处理器状态信息、进程控制信息。具体如下：
- **进程标识信息**
    - 该进程的标识符 `pid`
    - 创建该进程的父进程的标识符 `ppid`
    - 创建该进程的用户的标识符 `uid`
- **处理器状态信息**
    - 用户可见寄存器 - 用户可访问的通用寄存器
    - 控制和状态寄存器 - 用户控制处理器操作的处理器寄存器
        - 程序计数器 `pc`：下一条待执行指令的内存地址
        - 条件码：最近算术或逻辑运算的结果 (符号、零、进位、相等、溢出)
        - 状态信息：一些标志信息如：中断允许/禁止标志、执行模式(用户、内核)
    - 栈指针 - 栈顶指针，保存堆栈顶的内存地址
- **进程控制信息** 
    - 调度和状态信息 - OS执行调度所需要的信息
        - 进程状态：就绪、运行、等待、终止
        - 优先级：描述进程调度优先级的一个或多个域
        - 调度相关信息：具体取决于调度算法，主要等待时间总量(调整优先级、顺序)、进程上次运行的执行时间总量(用于预测)
        - 事件：导致进程阻塞的事件标识
    - 数据结构
        - 通过某些数据结构链接到其他进程
    - 进程间通信
        - 用于两个无关进程间通信的各种标记、信号和信息
    - 进程特权
    - 存储管理
        - 指向分配给该进程的 段表和页表 的指针
    - 资源所有权和使用情况
        - 进程控制的资源，如打开文件...

Linux下用`struct task_struct`来表示PCB，可以在`/usr/src/linux-headers-5.3.0-40/include/linux/sched.h`查看结构体的定义。

![GkQ02j.png](https://s1.ax1x.com/2020/03/28/GkQ02j.png)



一些重要的信息：
- 进程 `id` ， 类型`pid_t` （命令`ps aux`查看所有进程信息-进程id）
- 进程状态 - 就绪、运行、阻塞(等待)、终止
- 进程切换时 需要保存和恢复的寄存器
- 描述虚拟地址空间的信息 （映射表）
- 描述控制终端的信息
- 当前进程的工作目录
- `umask` 掩码
- 文件描述符表 - 包含很多指向`file`结构体的指针
- 和 信号`signal` 相关信息
- 用户`id` 和 组`id`
- 会话 和 进程组
- 进程可以使用的资源上限

## 3.论述进程的基本特征

==并发==(重要)：多个进程可以交替执行，一起向前推进，由CPU调度选择执行顺序，实现宏观并发，微观串行。

==动态==(本质)：进程是动态执行的，它的状态信息保存在PCB中，标志此进程的状态是运行、就绪还是等待。==进程是一个正在执行的程序实例，存在生命周期。==

==独立性==：各进程地址空间相互独立。

==异步性==：按照各自进程独立的 且 不可预测的速度向前推进。

## 4.以图为例，分析五状态进程模型

[![GmVqtU.png](https://s1.ax1x.com/2020/03/30/GmVqtU.png)](https://imgchr.com/i/GmVqtU)

空 -> 新建：创建了一个执行一个程序的新进程。

新建 -> 就绪：OS准备好接纳一个新进程时 - OS需要限制活跃进程的数量

就绪 -> 运行：当前进程被OS调度，从就绪状态变为运行状态

运行 -> 就绪：当前进程被抢占或者时间片结束，OS调度下一个就绪进程，从运行状态变为就绪状态

就绪 -> 等待：当前进程因为等待事件(资源)或I/O中断，从运行状态变为等待状态

等待 -> 就绪：当前进程等待的事件或I/O中断到来，从等待状态变为就绪状态

运行 -> 终止：当前进程正常结束或者异常结束，从运行状态变为终止状态

注意：就绪态只等待CPU资源，等待态是等待除CPU资源的其他资源。

## 5.为什么引入挂起状态，它和阻塞状态的本质区别是什么？

因为计算机内存资源是有限的，如果内存中加载了大量进程，系统会为了减轻内存负荷，将部分进程挂起，就是将这个进程镜像移到外存，当内存资源不紧张或者用户需要使用该进程时，再由挂起恢复到就绪。

挂起状态：将内存中处于阻塞、就绪、甚至是执行状态的进程存放到外存，不再参与CPU的竞争，我们把这种静止状态称为挂起状态。

挂起状态和阻塞状态最本质的区别就是进程镜像是否在内存

## 6.论述进程切换与模式切换的区别。什么情况下会发生进程切换，什么情况下会发生模式切换 *

进程切换是指调度另一个就绪进程占用处理器执行，此时将会保存上一个进程的上下文，恢复下一个进程的上下文。而模式切换是指用户模式和内核模式的相互切换。

进程切换发生在普通中断、陷阱、进行系统调用时，而模式切换发生在进行系统调用或中断时。

进程切换其实就是在内核下的调度程序完成的，所以每次进程切换会涉及到两次模式切换。

ps：模式切换并不一定会导致进程切换(如I/O状态、某些系统调用`getpid()`)，但进程切换一定会导致模式切换(必须在操作系统内核模式下完成)。

## 7.什么是中断？中断的处理过程如何？

中断通常有硬中断和软中断，硬中断通常是计算机硬件、系统发生错误，强制进入内核的异常处理程序，处理完成后再由内核返回给用户继续当前指令的执行或者直接终止；软中断是用户通过系统调用发生模式的切换，意图进入内核，请求服务。

## 8.什么是系统调用？

系统调用是用户向内核请求服务的一层接口，通过系统调用的方式，从用户态进入内核态

## 9.比较不同类型线程的缺点 *

**用户线程**：
- 优点
    - 1.单个进程间多个线程之间的切换可以不通过内核，切换的开销非常小
- 缺点
    - 1.一个线程崩溃(或阻塞)会导致当前进程内的其余线程跟着一起崩溃(或阻塞)。
    - 2.由于内核不可见，导致多线程进程中每个线程分配的CPU时间少。
    - 3.不支持多处理的多线程并行执行(因为内核仍然是以进程为执行单位调度)

**内核线程**：
- 优点
    - 1.以线程作为执行调度的最小单元，使得多线程的进程分配的CPU时间更多。
    - 2.支持多处理器的多线程并行执行
    - 3.一个线程崩溃(或阻塞)不会导致当前进程内的其余线程跟着一起崩溃(或阻塞)
- 缺点
    - 1.同一进程内的线程切换需要进入内核模式，所以切换的开销相对用户线程的较大

**轻量级进程(混合方法)**：整合了用户线程和内核线程
- 线程创建在用户空间完成
- 线程调度和同步由应用程序完成
- 一个应用程序的多个线程被映射到一些内核线程上

## 10.说明fork()函数的作用，并举例说明 *

`fork()`函数用于创建一个子进程，并且根据在父子进程内返回值的不同(父进程返回子进程的`pid`，而子进程返回`0`)，常常通过条件分支语句让父子进程执行不同的代码块。

![GkQwGQ.png](https://s1.ax1x.com/2020/03/28/GkQwGQ.png)

通常和`exec()`函数族组合使用，在父进程内创建一个子进程，让子进程来运行新程序。

比如，`shell`父进程中就含有大量的`fork() -> exec()`机制，用于解释命令，执行用户指定程序。
