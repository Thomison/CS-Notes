# 互斥与同步

## 一、背景

### 并发进程的正确性

- **独立进程**
  - 不和其他进程共享资源和状态
  - **确定性**：输入状态决定输出结果
  - **可重现性**：能够重现起始条件
  - 调度顺序不重要
-  **并发进程**
  - 在多个进程间共享资源和状态
  - 不确定性
  - 不可重现
- 并发进程的**正确性**
  - 执行过程的不确定性(无法预测进程间执行顺序)和不可重现
  - 程序错误是**间歇性产生**的



### 进程并发执行的好处

进程需要和计算机中的其他进程和设备进行协作

- **1.共享资源**
  - 比如说：多个用户使用同一台计算机、银行存款余额可以在多个ATM机上操作
- **2.加速**
  - I/O操作和CPU计算可以重叠 - 并行
  - 程序可以划分为多个模块，然后在不同的处理器上执行 - 并行3.
- **3.模块化**
  - 将打程序划分为若干小程序
    - 比如说：编译为例，gcc会分别调用cpp(预处理)、cc1、cc2(编译)、as(汇编)、ls(链接)
  - 使得系统易于复用和拓展



### 并发进程错误实例 - 并发创建新进程时的标识分配

程序可以调用`fork()`来创建一个新的进程

- OS会需要分配一个新的并且唯一的进程ID

- 内核中系统调用会运行：

  ```c
  next_pid = next_pid++		//使内核中这个共享变量自增
  ```

- 翻译为机器指令

  ```assembly
  LOAD next_pid Reg1 #先从共享变量读取到寄存器
  STORE Reg1 new_pid  #存储到本地变量
  INC Reg1 	#自增
  STORE Reg1 next_pid #再更新内核中对应共享变量 
  ```



两个进程并发执行时我们的预期结果：

- 进程1得到ID为100
- 进程2得到ID为101
- 现在的`next_pid`为102



可能引发的并发错误：

[![GQdMVA.png](https://s1.ax1x.com/2020/03/31/GQdMVA.png)](https://imgchr.com/i/GQdMVA)

也就是说在进程A读和修改变量`next_pid`之间的时候，进程A被时间中断，然后进程B得到调度，此时因为`next_pid`还未被进程A修改，所以它读取到的是之前的值为100，然后它继续执行修改、读取，使得`next_pid`为101，然后进程A得到调度，此时它从之前读取到的值100开始修改，保存`next_pid`还是101。

这时，进程A和B运行的结果是它们两个都得到相同的进程ID为100，并且`next_pid`只自增了一次，结果为101。



引发这个并发错误的原因是对共享数据的读和写不是原子操作，使得中途发生中断，导致多个进程同时读写这个共享数据，不能保证其正确性。



### 原子操作

原子操作指：一次不存在任何中断或失败的操作(一系列指令组成)

- 要么操作成功完成
- 要么操作没有执行
- 不会出现部分执行的状态

OS通过同步机制保证并发执行正确的实质：保证一些关键操作(读写共享资源)是原子操作。



## 二、现实生活中的同步问题

将操作系统和现实生活进行类比

 - 例如：家庭采购协调

![GQdmKe.png](https://s1.ax1x.com/2020/03/31/GQdmKe.png)

我们可以把A和B看作两个进程，冰箱看作计算机，面包看作计算机中的共享资源。



问题分析：

- 保证采购的成功和高效
  - 当需要采购时，得有人去进行相应的采购(面包)
  - 当同时有多个人想要采购意愿时，只允许一个人前去采购
- 可能的解决办法
  - 冰箱上设置锁和钥匙
  - 去采购时需要锁住冰箱并拿走钥匙
- 导致的问题
  - 其他人无法取到冰箱中的其他东西(效率降低)



### 方案一

利用便签(可以看作某种标志)避免重复采购

- 采购之前留下便签
- 采购完之后移除便签
- 其他人当看到存在便签时，就不去采购

相应伪代码：

```c
if (nobread) {
    if (noNote) {
        leave Note;
        /* ---- */
        buy break;
        /* ---- */
        remove Note;
    }
}
```



分析：

![GQdVgO.png](https://s1.ax1x.com/2020/03/31/GQdVgO.png)

这种解决方案可能会导致同时有多个人去采购

- 在检查面包/便签 和 留下便签之间的同时，另外有人也来进行检查，他们检查的结果都将是不存在便签，都会前去采购，导致重复。



### 方案二

先留下便签，再进行检查

```c
leave Note;
if (nobread) {
    if (noNote) {
        /* ---- */
        buy bread;
        /* ---- */
    }
}
remove Note;
```



分析：

![GQdE8K.png](https://s1.ax1x.com/2020/03/31/GQdE8K.png)

这种解决方案可能会导致都不会采购

- 因为总是会检查到自己留下的标签



### 方案三

给便签增加标记，用来区分不同人留下的便签

```c
leave note_1;
if (no note_2) {
    if (no bread) {
        /* ---- */
        buy bread;
        /* ---- */
    }
}
remove note_1;
```

```c
leave note_2;
if (no note_1) {
    if (no bread) {
        /* ---- */
        buy bread;
        /* ---- */
    }
}
remove note_2;
```



分析：

![GQdF4x.png](https://s1.ax1x.com/2020/03/31/GQdF4x.png)

这种解决方案仍然可能会导致没有人去采购

- 当两个人几乎同时到达时，各自看到对方留下的便签，以为已经有人去采购了，所以双方都不会去采购。



### 方案四

现在让两个人采用不同的处理流程

![GQavgU.png](https://s1.ax1x.com/2020/03/31/GQavgU.png)



分析：

我们让A在去采购前持续检查`note_2`的状态(忙等待)，直到`note_2`标志被移除，而B如果检查到`note_1`的存在则从最开始重新执行一次。让它们两个执行不同的处理路程使得并发错误得以解决。

但是，它虽然有效，但是由于代码片的不同而导致的复杂度，并且很难验证有效性，当进程开始增多时很难处理。还有就是：当A在**忙等待**时，不能做其他事情，浪费了CPU时间。



### 方案五

利用两个原子操作实现一个锁 `lock`

- `Lock.Acquire()`加锁
  - 一直等待直到锁被释放，获得锁
  - 如果多个线程同时等待同一个锁，当锁被释放，随机选取一个线程获得锁
- `Lock.Release()`解锁
  - 解锁并唤醒任何等待中的线程



基于原子锁的解决方案：

```c
breakLock.Acquire()
if (nobread) {				//进入临界区
    /* ---- */					
    buy bread;					//临界区
    /* ---- */					
breakLock.Release();		//退出临界区
}
```



### 进程的交互关系：相互感知程度

- 独立
- 通过**共享**进行协作
- 通过**通信**进行协作



![GQaj3T.png](https://s1.ax1x.com/2020/03/31/GQaj3T.png)


会产生的问题：

- 互斥
  - **一个进程占用资源**时，其他进程不能使用这个资源
- 死锁
  - 多个进程各占用**部分资源**，形成**循环等待**
- 饥饿
  - 其他进程可能轮流占用资源，导致一个进程**一直得不到资源**



## 三、临界区

### 临界区

```
entry section
	critical section
exit section
	remainder section
```

- 临界区
  - 进程中**访问临界资源**的一段需要**互斥执行的代码**(同一时间只有一个进程正在执行这个代码段)
- 进入区
  - **检查是否可以进入临界区**的一段代码
  - 如果可以进入，需要**设置“正在访问临界区”的标志**
- 退出区
  - 消除之前设置的“正在访问临界区”的标志
- 剩余区



### 临界区的访问原则

- **空闲则入**
  - 没有进程在临界区时，任何进程可以进入(意思是进程不会因为未在临界区的进程而阻塞)
- **忙则等待**
  - 有进程在临界区时，其他任何进程不可以进入(互斥访问临界资源)
- **有限等待**
  - 等待进入临界区的进程不能无限期的等待(不能出现死锁或者饥饿)
- 让权等待(可选)
  - 不能进入临界区的进程，应该释放CPU资源，进入阻塞状态，而不是处于忙等状态以消耗CPU资源



### 临界区的实现方法

- 禁用中断
- 软件方法
- 更高级的抽象方法



## 实现同步互斥 方法一：禁用硬件中断

思路：没有**中断**(时钟中断)，也就没有了**上下文切换**(进程间切换)，也就没有了**并发**(并发错误)

- 硬件将中断延迟到中断被启用之后

- 现代计算机体系结果提供**指令**来实现禁用中断

  ```c
  //进入临界区：禁止所有中断 并保存标志
  local_irq_save(unsigned long flags);
  crtical section;
  //离开临界区：恢复所有中断 并恢复标志
  local_irq_restore(unsigned long flags);
  ```



### 这个方法存在的缺点：

- 1.禁用中断后，该进程无法被停止
  - 意味着整个系统都会停止
  - 导致其他进程饥饿
- 2.临界区可能很长
  - 无法确定响应中断所需时间
- 3.只使用于单处理器，无法适用于多处理器计算机



## 实现同步互斥 方法二：基于软件的同步

### 第一次尝试

![GQaL40.png](https://s1.ax1x.com/2020/03/31/GQaL40.png)

即严格轮转策略(谦让式)，用一个共享变量来标志进入临界区的线程，不满足“空闲则入”原则，并且忙等待不满足“让权等待”原则



### 第二次尝试

![GQaqNq.png](https://s1.ax1x.com/2020/03/31/GQaqNq.png)

用两个标志位分别标记两个线程是否在临界区，如果当前线程想要进入临界区**先检查**对方是否在临界区，**再设置自己的标志位**(主动式)，这种办法满足了“空闲让进”原则，但不满足“忙则等待”原则，如果两个进程几乎同时想要进入临界区时，它们都可能绕过忙等，直接进入临界区，导致多个进程同时处于临界区。



### 第三次尝试

![GQabEn.png](https://s1.ax1x.com/2020/03/31/GQabEn.png)

调整为先设置自己的标志位(表示想要进入临界区)，再检查对方是否在临界区，这虽然满足了“忙则等待”原则，但又不满足“空闲则入”原则，因为如果两个进程几乎同时想要进入临界区时，可能导致两个都留下了标记，但是都检查到了对方正在访问临界区，所以导致两个进程都在忙等。



### Peterson算法

是满足两个线程之间互斥访问的经典的**软件解决办法**

![GQa7Hs.png](https://s1.ax1x.com/2020/03/31/GQa7Hs.png)



代码：

```c
do {
    /* 进入区 */
    flag[i] = true; 	//表示自己准备好访问临界区
    turn = j;		//设置该轮到对方(谦让)
    //当前进程能够进入临界区的条件：1.对方没有准备好进入临界区；2.当前轮到自己(当两个进程进程竞争结果是：对方谦让给了自己)
    while (flag[j] && turn == j);
    
  		/* 临界区 */
    CRTICAL SECTION;
    
    /* 退出区 */
    flag[i] = false;	//表示自己没有准备好访问临界区
    
    REMAINDER SECTION;
} while (true);
```

该算法的巧妙之处在于解决了两个进程几乎同时想要进入临界区时，用另外一个共享变量`turn`来标记两个进程谦让的结果(即先提出想要进入临界区的进程)，使得两个进程必然一前一后互斥的访问临界区，既满足了“忙则等待”，又满足了“空闲则入”原则，但仍然存在忙等待问题，不能很好的支持“让权等待”。



###  Dekkers算法

![GQaTBj.png](https://s1.ax1x.com/2020/03/31/GQaTBj.png)



### 多线程同步互斥的软件解决办法 (Eisenberg 和 McGuire)

![GQa5jg.png](https://s1.ax1x.com/2020/03/31/GQa5jg.png)



### 基于软件的解决办法的分析

- 复杂
  - 需要两个进程间的共享变量
- 忙等待
  - 不满足“让权等待”原则
  - 蓝非CPU时间



## 实现同步和互斥 方法三：更高级的抽象方法

- 硬件提供一些同步原语
  - 中断禁用、**原子操作指令**等
- OS提供更高级的编程抽象来简化进程同步
  - 如：**锁、信号量**
  - 它底层是用硬件原语来构建的



### 锁 Lock

- 锁是一个抽象的数据结构

  - 一个二进制变量 (它只有两个状态：锁定 和 解锁)
  - `Lock::Acqure`
  - `Lock::Release`

- 使用锁来控制临界区的访问

  ```c
  lock_next_pid->Acqure();
  new_pid = next_pid++;
  lock_next_pid->Release();
  ```



### 原子操作指令

- 现代CPU体系结构提供了一些特殊的原子操作指令

- 测试和置位 `Test-and-Set`指令
  - 从内存单元中加载读取该值
  - 测试该值是否为`1`。（返回true或false）
  - 内存单元该值设置为`1`

- 交换指令 `exchange`
  - 交换内存中的两个值



### 使用TS指令和交换指令实现自旋锁

![GQa4gS.png](https://s1.ax1x.com/2020/03/31/GQa4gS.png)

获取锁的内部用忙等待来实现，持续检查`value`值是否为`1`，即锁是否被释放。



![GQah38.png](https://s1.ax1x.com/2020/03/31/GQah38.png)

无忙等待实际上通过把等待的线程放入等待队列中，然后去调度其他线程，以避免当前线程处于忙等待状态。



### 原子操作指令实现的锁的特征

优点：

- 适用于单处理器或共享内存的多处理器中任意数量的进程同步
- 简单容易证明
- 支持多临界区

缺点：

- 忙等待锁消耗CPU时间
- 可能导致饥饿
  - 进程释放锁时有多个等待进程时
- 死锁J
  - **低优先级进程**拥有临界区，但此时请求访问临界区的**高优先级进程**获得CPU并等待临界区 （即优先级反转问题）



## 对同步方法的总结

1.锁是一种高级的同步抽象方法

- 互斥可以使用锁来实现
- 但需要硬件支持(**原子操作指令**)

2.常用的三种同步实现方法

- 禁用中断(仅仅用于单处理器)
- 软件方法(复杂、忙等待)
- 原子操作指令实现的抽象方法(单处理器、多处理器均适合)
